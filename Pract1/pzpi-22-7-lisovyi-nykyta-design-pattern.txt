Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії


Звіт 
з практичного заняття №1
з дисципліни «Архітектура програмного забезпечення»
за темою «Патерн проєктування Decorator»








Харків 2025

1 ІСТОРІЯ ЗМІН

　　　　Таблиця 1.1 – Історія змін звіту
№	Дата	Версія звіту	Опис змін та виправлень
1	03.05.2025	0.1	Створено презентацію “Патерн проєктування Decorator”
2	04.05.2025	0.2	Записано відео презентацію
3	05.05.2025	0.3	Створено розділ «Завдання»,
 «Опис виконаної роботи», 
 «Висновки» та додатки 
«Додаток А», «Додаток Б», «Додаток В»
4	06.05.2025	1.0	перевірено відповідність вимогам ДСТУ 3008:2015
　　　　
　　　　
　　　　
　　　　

2 ЗАВДАННЯ
　　　　
　　　　Вивчити патерн проєктування Decorator, з’ясувати його значення у розробці програмного забезпечення та основні принципи його роботи. Дослідити приклади реалізації патерну Decorator мовою Python. Розглянути приклади використання цього патерну для гнучкого розширення функціональності об’єктів у реальних системах, зокрема у контексті композиції замість спадкування.
　　　　
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Аналіз патерну Decorator

	Патерн Decorator належить до структурних патернів проєктування і призначений для динамічного додавання нових обов’язків об’єктам без зміни їхнього вихідного коду. Основна ідея полягає в обгортанні базового об’єкта спеціальними класами-декораторами, які розширюють його поведінку, зберігаючи при цьому оригінальний інтерфейс. Це дозволяє уникнути створення численних підкласів, що ускладнюють структуру програми, і сприяє модульності та гнучкості системи.
　　　　Основні принципи роботи:
Використання композиції замість спадкування для розширення функціональності.
Забезпечення прозорості для клієнтського коду через збереження інтерфейсу базового об’єкта.
Можливість комбінування кількох декораторів у довільному порядку для досягнення потрібної поведінки.
Відповідність принципу відкритості/закритості, що дозволяє розширювати функціональність без модифікації існуючого коду.

　　　　Патерн широко застосовується в реальних системах, наприклад, для додавання візуальних ефектів у графічних інтерфейсах, розширення обробки потоків вводу/виводу, логування у вебфреймворках або кешування в системах керування базами даних.

　　　　3.2 Аналіз прикладів коду на мові Python
　　　　Для поглибленого розуміння патерну Decorator було досліджено приклад його реалізації мовою Python. Приклад коду наведено у додатку В.

　　　　3.2.1 Реалізація патерну Decorator у Python
　　　　Реалізація патерну Decorator у Python базується на створенні абстрактного базового класу Beverage, який визначає інтерфейс для об’єктів (методи get_description та cost). Конкретний клас Espresso виступає як базовий об’єкт, що реалізує цей інтерфейс. Декоратори, такі як MilkDecorator, обгортають базовий об’єкт, додаючи нові функції (наприклад, молоко до напою) та відповідні зміни до опису й вартості.
　　　　У прикладі клас BeverageDecorator забезпечує базову функціональність декоратора, передаючи виклики методів обгорнутому об’єкту, а конкретний декоратор MilkDecorator додає власну поведінку. Клієнтський код може створювати комбінації декораторів, наприклад, додаючи молоко до еспресо, без зміни базового класу. Ця реалізація демонструє гнучкість патерну, оскільки нові декоратори (наприклад, для цукру чи сиропу) можна додати без модифікації наявного коду. Використання об’єктно-орієнтованого підходу сприяє легшому тестуванню та підтримці коду, а ізоляція логіки декораторів забезпечує модульність системи.
　　　　

4 ВИСНОВКИ

　　　　У ході роботи було проаналізовано патерн проєктування Decorator, який належить до структурних патернів. Він дозволяє гнучко розширювати функціональність об’єктів шляхом їх обгортання без зміни вихідного коду. Було встановлено, що патерн використовує композицію замість спадкування, уникаючи створення численних підкласів. Це забезпечує прозорість для клієнтського коду, адже декоровані об’єкти зберігають той самий інтерфейс. Дослідження показало, що Decorator відповідає принципу відкритості/закритості, сприяючи модульності систем. Практичне застосування патерну охоплює графічні інтерфейси, обробку потоків і вебфреймворки. Отже, Decorator є ефективним інструментом для створення адаптивних і модульних програм.

ДОДАТОК А ПОСИЛАННЯ НА ВІДЕОЗАПИС ДОПОВІДІ ТА ХРОНОЛОГІЧНИЙ ОПИС

Відеозапис доповіді на YouTube: https://youtu.be/FHMXL_1DqK0
00:00 - 00:33 -- Тема та зміст роботи 
00:33 - 01:00 -- Визначення патерну 
01:00 - 01:35 -- Мета та мотивація патерну 
01:35 - 02:10 -- Принцип роботи патерну 
02:10 - 03:30 -- Приклад структури патерну 
03:30 - 04:05 -- Застосування в реальних системах 
04:05 - 04:35 -- Переваги патерну 
04:35 - 04:55 -- Недоліки патерну 
04:55 - 05:40 -- Висновки та Джерела


ДОДАТОК Б
Презентація

Рисунок Б.1 – Титульна сторінка презентації


Рисунок Б.2 – Тема й мета


Рисунок Б.3 – Зміст презентації


Рисунок Б.4 – Визначення патерну Decorator


Рисунок Б.5 – Мета патерну


Рисунок Б.6 – Принцип роботи патерну Decorator

Рисунок Б.7 – Приклад структури патерну


Рисунок Б.8 – Демонстрація роботи



Рисунок Б.9 – Застосування патерну в реальних системах


Рисунок Б.10 – Переваги патерну 

Рисунок Б.11 – Недоліки патерну проєктування


Рисунок Б.12 – Висновки

Рисунок Б.13 – Джерела

ДОДАТОК В ПРОГРАМНИЙ КОД

1  from abc import ABC, abstractmethod
2  
3  class Beverage(ABC):
4      @abstractmethod
5      def get_description(self):
6          pass
7      @abstractmethod
8      def cost(self):
9          pass
10 
11 class Espresso(Beverage):
12     def get_description(self):
13         return "Еспресо"
14     def cost(self):
15         return 2.0
16 
17 class BeverageDecorator(Beverage):
18     def __init__(self, beverage):
19         self._beverage = beverage
20     def get_description(self):
21         return self._beverage.get_description()
22     def cost(self):
23         return self._beverage.cost()
24 
25 class MilkDecorator(BeverageDecorator):
26     def get_description(self):
27         return f"{self._beverage.get_description()} з молоком"
28     def cost(self):
29         return self._beverage.cost() + 0.5
30 
31 class SugarDecorator(BeverageDecorator):
32     def get_description(self):
33         return f"{self._beverage.get_description()} з цукром"
34     def cost(self):
35         return self._beverage.cost() + 0.2
36 
37 if __name__ == "__main__":
38     espresso = Espresso()
39     espresso_with_milk = MilkDecorator(espresso)
40     espresso_with_milk_and_sugar = SugarDecorator(espresso_with_milk)
41     print(
42         f"Напій: {espresso.get_description()},"
43         f"ціна: ${espresso.cost()}"
44     )
45     print(
46         f"Напій: {espresso_with_milk.get_description()},"
47         f"ціна: ${espresso_with_milk.cost()}"
48     )
49     print(
50         f"Напій: {espresso_with_milk_and_sugar.get_description()},"
51         f"ціна: ${espresso_with_milk_and_sugar.cost()}"
52     )
